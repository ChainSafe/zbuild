//! Generate a build.zig file from a Config

const std = @import("std");

const Config = @import("Config.zig");
const ConfigBuildgen = @This();

const Writer = std.io.AnyWriter;

allocator: std.mem.Allocator,
config: Config,
writer: Writer,

write_files: std.StringArrayHashMap(Config.WriteFile),
options: std.StringArrayHashMap(Option),
options_modules: std.StringArrayHashMap(Config.OptionsModule),
modules: std.StringArrayHashMap(Config.Module),
dependencies: std.StringArrayHashMap(void),
executables: std.StringArrayHashMap(Config.Executable),
runs: std.StringArrayHashMap(Config.Run),

const Option = struct {
    type_name: []const u8,
    optional: bool,
};

pub fn init(allocator: std.mem.Allocator, config: Config, writer: Writer) ConfigBuildgen {
    return ConfigBuildgen{
        .allocator = allocator,
        .config = config,
        .writer = writer,
        .write_files = std.StringArrayHashMap(Config.WriteFile).init(allocator),
        .options = std.StringArrayHashMap(Option).init(allocator),
        .options_modules = std.StringArrayHashMap(Config.OptionsModule).init(allocator),
        .modules = std.StringArrayHashMap(Config.Module).init(allocator),
        .dependencies = std.StringArrayHashMap(void).init(allocator),
        .executables = std.StringArrayHashMap(Config.Executable).init(allocator),
        .runs = std.StringArrayHashMap(Config.Run).init(allocator),
    };
}

pub fn deinit(self: *ConfigBuildgen) void {
    self.write_files.deinit();
    self.options.deinit();
    self.options_modules.deinit();
    self.modules.deinit();
    self.dependencies.deinit();
    self.executables.deinit();
    self.runs.deinit();
}

pub fn write(self: *ConfigBuildgen) !void {
    try self.writeLn(
        \\// This file is generated by zbuild. Do not edit manually.
        \\
        \\const std = @import("std");
        \\
        \\pub fn build(b: *std.Build) void {{
        \\    const target = b.standardTargetOptions(.{{}});
        \\    const optimize = b.standardOptimizeOption(.{{}});
        \\
    ,
        .{},
        .{ .indent = 0 },
    );

    // add all config items without linking depends_on, lazy paths, or imports

    if (self.config.dependencies) |dependencies| {
        try self.writeItems(Config.Dependency, writeDependency, dependencies);
    }
    if (self.config.write_files) |write_files| {
        try self.writeItems(Config.WriteFile, writeWriteFile, write_files);
    }
    if (self.config.options) |options| {
        try self.writeItems(Config.Option, writeOption, options);
    }
    if (self.config.options_modules) |options_modules| {
        try self.writeItems(Config.OptionsModule, writeOptionsModule, options_modules);
    }
    if (self.config.modules) |modules| {
        try self.writeItems(Config.Module, writeModule, modules);
    }
    if (self.config.executables) |executables| {
        try self.writeItems(Config.Executable, writeExecutable, executables);
    }
    if (self.config.libraries) |libraries| {
        try self.writeItems(Config.Library, writeLibrary, libraries);
    }
    if (self.config.objects) |objects| {
        try self.writeItems(Config.Object, writeObject, objects);
    }

    if ((self.config.tests != null and self.config.tests.?.count() > 0) or self.modules.count() > 0) {
        try self.writeLn(
            \\const tls_run_test = b.step("test", "Run all tests");
            \\
        , .{}, .{});
    }
    // ensure a test is created for every module in the project, not just explicitly defined tests
    for (self.modules.keys()) |name| {
        if (self.config.tests == null or !self.config.tests.?.contains(name)) {
            try self.writeTest(name, .{
                .root_module = .{ .name = name },
                .filters = &.{},
            });
            try self.writer.writeAll("\n");
        }
    }
    if (self.config.tests) |tests| {
        try self.writeItems(Config.Test, writeTest, tests);
    }
    if (self.config.fmts) |fmts| {
        try self.writeLn(
            \\const tls_run_fmt = b.step("fmt", "Run all fmts");
            \\
        , .{}, .{});
        try self.writeItems(Config.Fmt, writeFmt, fmts);
    }
    if (self.config.runs) |runs| {
        try self.writeItems(Config.Run, writeRun, runs);
    }

    // add files/dirs to write files

    if (self.config.write_files) |write_files| {
        try self.writeItems(Config.WriteFile, writeWriteFileItems, write_files);
    }

    // link all imports

    if (self.config.modules) |modules| {
        try self.writeImports(Config.Module, modules);
    }
    if (self.config.executables) |executables| {
        try self.writeImports(Config.Executable, executables);
    }
    if (self.config.libraries) |libraries| {
        try self.writeImports(Config.Library, libraries);
    }
    if (self.config.objects) |objects| {
        try self.writeImports(Config.Object, objects);
    }
    if (self.config.tests) |tests| {
        try self.writeImports(Config.Test, tests);
    }
    // make sure all unused variables are used
    // target and optimize that aren't used (when all modules define them)
    var target_unused = true;
    var optimize_unused = true;
    for (self.modules.values()) |module| {
        if (module.target == null) {
            target_unused = false;
        }
        if (module.optimize == null) {
            optimize_unused = false;
        }
    }
    if (target_unused) {
        try self.writeLn("_ = target;", .{}, .{});
    }
    if (optimize_unused) {
        try self.writeLn("_ = optimize;", .{}, .{});
    }
    // options modules and dependencies that aren't imported
    for (self.options_modules.keys()) |name| {
        var options_module_unused = true;
        blk: for (self.modules.values()) |module| {
            if (module.imports) |imports| {
                for (imports) |import| {
                    if (std.mem.eql(u8, name, import)) {
                        options_module_unused = false;
                        break :blk;
                    }
                }
            }
        }
        if (options_module_unused) {
            try self.writeLn("_ = {s};", .{try fmtId("options_module", name)}, .{});
        }
    }
    for (self.dependencies.keys()) |name| {
        var dependency_unused = true;
        blk: for (self.modules.values()) |module| {
            if (module.imports) |imports| {
                for (imports) |import| {
                    if (std.mem.eql(u8, name, import)) {
                        dependency_unused = false;
                        break :blk;
                    }
                }
            }
        }
        if (dependency_unused) {
            try self.writeLn("_ = {s};", .{try fmtId("dep", name)}, .{});
        }
    }

    try self.writeLn("}}", .{}, .{ .indent = 0 });
}

fn writeItems(
    self: *ConfigBuildgen,
    comptime T: type,
    comptime writeItem: fn (*ConfigBuildgen, []const u8, T) anyerror!void,
    items: std.StringArrayHashMap(T),
) !void {
    const names = items.keys();
    const values = items.values();
    for (names, values) |name, item| {
        try writeItem(self, name, item);
        try self.writer.writeAll("\n");
    }
}

fn writeImports(
    self: *ConfigBuildgen,
    comptime T: type,
    items: std.StringArrayHashMap(T),
) !void {
    const keys = items.keys();
    const values = items.values();
    for (keys, values) |name, item| {
        const imports = switch (T) {
            Config.Module => item.imports orelse continue,
            else => blk: {
                const module_config = switch (item.root_module) {
                    .module => |m| m,
                    .name => continue,
                };
                break :blk if (module_config.imports) |imports| imports else continue;
            },
        };

        try self.writeImport(name, imports);
        try self.writer.writeAll("\n");
    }
}

pub fn writeWriteFile(self: *ConfigBuildgen, name: []const u8, item: Config.WriteFile) !void {
    const write_files_id = try allocFmtId(self.allocator, "write_files", name);
    defer self.allocator.free(write_files_id);

    try self.writeLn(
        \\const {s} = b.{s}();
    ,
        .{
            write_files_id,
            if (item.private orelse false) "addWriteFiles" else "addNamedWriteFiles",
        },
        .{},
    );
    try self.write_files.put(name, item);
}

pub fn writeWriteFileItems(self: *ConfigBuildgen, name: []const u8, item: Config.WriteFile) !void {
    const write_files_id = try allocFmtId(self.allocator, "write_files", name);
    defer self.allocator.free(write_files_id);

    if (item.items) |items| {
        for (items.keys(), items.values()) |key, value| {
            switch (value) {
                .file => |f| {
                    try self.writeLn(
                        \\_ = {s}.addCopyFile({s}, "{s}");
                    ,
                        .{ write_files_id, try self.resolveLazyPath(f.path, SourcesForWriteFiles), key },
                        .{},
                    );
                },
                .dir => |d| {
                    try self.writeLn(
                        \\_ = {s}.addCopyDirectory({s}, "{s}", .{{ .exclude_extensions = {s}, include_extensions = {s} }});
                    ,
                        .{
                            write_files_id,
                            try self.resolveLazyPath(d.path, SourcesForWriteFiles),
                            key,
                            try strSliceLiteral(d.exclude_extensions) orelse "&.{}",
                            try strSliceLiteral(d.include_extensions) orelse "null",
                        },
                        .{},
                    );
                },
            }
        }
    }
}

pub fn writeOption(self: *ConfigBuildgen, name: []const u8, item: Config.Option) !void {
    const t, const default, const description = blk: switch (item) {
        .bool => |b| {
            break :blk .{
                "bool",
                if (b.default) |d| try std.fmt.allocPrint(self.allocator, "{}", .{d}) else null,
                b.description,
            };
        },
        .@"enum" => |e| {
            break :blk .{
                try std.fmt.allocPrint(self.allocator, "enum {s}", .{e.enum_options}),
                if (e.default) |d| try std.fmt.allocPrint(self.allocator, ".{s}", .{d}) else null,
                e.description,
            };
        },
        .enum_list => |e| {
            const enum_id = try allocFmtId(self.allocator, "Enum", name);
            try self.writeLn("const {s} = enum {s};", .{ enum_id, e.enum_options }, .{});
            break :blk .{
                enum_id,
                if (e.default) |d| try std.fmt.allocPrint(self.allocator, "{s}", .{try enumSliceLiteral(enum_id, d)}) else null,
                e.description,
            };
        },
        .string => |s| {
            break :blk .{
                "[]const u8",
                if (s.default) |d| try std.fmt.allocPrint(self.allocator, "\"{s}\"", .{d}) else null,
                s.description,
            };
        },
        .list => |l| {
            break :blk .{
                "[][]const u8",
                try strSliceLiteral(l.default),
                l.description,
            };
        },
        .lazy_path => |l| {
            break :blk .{
                "std.Build.LazyPath",
                if (l.default) |d| try self.resolveLazyPath(d, SourcesForOptions) else null,
                l.description,
            };
        },
        .lazy_path_list => |l| {
            break :blk .{
                "[]std.Build.LazyPath",
                try lazyPathSlice(l.default),
                l.description,
            };
        },
        .build_id => |b| {
            break :blk .{
                "std.zig.BuildId",
                try buildId(b.default),
                b.description,
            };
        },
        .int => |i| {
            break :blk .{
                i.type,
                if (i.default) |d| try std.fmt.allocPrint(self.allocator, "{}", .{d}) else null,
                i.description,
            };
        },
        .float => |i| {
            break :blk .{
                i.type,
                if (i.default) |d| try std.fmt.allocPrint(self.allocator, "{}", .{d}) else null,
                i.description,
            };
        },
    };

    const option_id = try allocFmtId(self.allocator, "option", name);
    defer self.allocator.free(option_id);

    if (default) |d| {
        try self.writeLn(
            \\const {s} = b.option({s}, "{s}", "{s}") orelse {s};
        ,
            .{ option_id, t, name, description orelse "", d },
            .{},
        );
    } else {
        try self.writeLn(
            \\const {s} = b.option({s}, "{s}", "{s}");
        ,
            .{ option_id, t, name, description orelse "" },
            .{},
        );
    }

    try self.options.put(name, .{ .type_name = t, .optional = default == null });
}

pub fn writeOptionsModule(self: *ConfigBuildgen, name: []const u8, item: Config.OptionsModule) !void {
    const options_id = try allocFmtId(self.allocator, "options", name);
    defer self.allocator.free(options_id);

    try self.writeLn(
        "const {s} = b.addOptions();",
        .{options_id},
        .{},
    );

    for (item.keys(), item.values()) |option_name, value| {
        try self.writeOption(option_name, value);
        const option = self.options.get(option_name) orelse return error.MissingOption;
        const option_id = try allocFmtId(self.allocator, "option", option_name);
        defer self.allocator.free(option_id);
        try self.writeLn(
            \\{s}.addOption({s}{s}, "{s}", {s});
        ,
            .{
                options_id,
                if (option.optional) "?" else "",
                option.type_name,
                option_name,
                option_id,
            },
            .{},
        );
    }

    try self.writeLn(
        \\const {s} = {s}.createModule();
    ,
        .{ try fmtId("options_module", name), options_id },
        .{},
    );

    try self.options_modules.put(name, item);
}

pub fn writeModule(self: *ConfigBuildgen, name: []const u8, item: Config.Module) !void {
    const module_id = try allocFmtId(self.allocator, "module", name);
    defer self.allocator.free(module_id);

    try self.writeLn(
        \\const {s} = b.createModule(.{{
    ,
        .{module_id},
        .{},
    );

    try self.writeField(
        "root_source_file",
        if (item.root_source_file) |f| try self.resolveLazyPath(f, SourcesForModules) else null,
        .{ .quote_str = false },
    );
    try self.writeField("target", try resolvedTarget(item.target), .{ .quote_str = false });
    try self.writeField("optimize", try optimize(item.optimize), .{ .quote_str = false });
    try self.writeField("link_libc", item.link_libc, .{});
    try self.writeField("link_libcpp", item.link_libcpp, .{});
    try self.writeField("single_threaded", item.single_threaded, .{});
    try self.writeField("strip", item.strip, .{});
    try self.writeField("unwind_tables", item.unwind_tables, .{});
    try self.writeField("dwarf_format", item.dwarf_format, .{});
    try self.writeField("code_model", item.code_model, .{});
    try self.writeField("stack_protector", item.stack_protector, .{});
    try self.writeField("stack_check", item.stack_check, .{});
    try self.writeField("sanitize_c", item.sanitize_c, .{});
    try self.writeField("sanitize_thread", item.sanitize_thread, .{});
    try self.writeField("fuzz", item.fuzz, .{});
    try self.writeField("valgrind", item.valgrind, .{});
    try self.writeField("pic", item.pic, .{});
    try self.writeField("red_zone", item.red_zone, .{});
    try self.writeField("omit_frame_pointer", item.omit_frame_pointer, .{});
    try self.writeField("error_tracing", item.error_tracing, .{});

    try self.writeLn("}});", .{}, .{});

    if (item.include_paths) |include_paths| {
        for (include_paths) |path| {
            try self.writeLn(
                \\{s}.addIncludePath({s});
            ,
                .{ module_id, try self.resolveLazyPath(path, SourcesForModules) },
                .{},
            );
        }
    }

    if (item.private orelse true) {
        try self.writeLn(
            \\b.modules.put(b.dupe("{s}"), {s}) catch @panic("OOM");
        ,
            .{ name, module_id },
            .{},
        );
    }
    try self.modules.put(name, item);
}

pub fn writeExecutable(self: *ConfigBuildgen, name: []const u8, item: Config.Executable) !void {
    const module_id = try self.allocModuleId(name, item.root_module);
    defer self.allocator.free(module_id);

    const exe_id = try allocFmtId(self.allocator, "exe", name);
    defer self.allocator.free(exe_id);

    try self.writeLn(
        "const {s} = b.addExecutable(.{{",
        .{exe_id},
        .{},
    );

    try self.writeField("name", name, .{});
    try self.writeField("version", try semanticVersion(item.version), .{ .quote_str = false });
    try self.writeField("root_module", module_id, .{ .quote_str = false });
    try self.writeField("linkage", item.linkage, .{});
    try self.writeField("max_rss", item.max_rss, .{});
    try self.writeField("use_llvm", item.use_llvm, .{});
    try self.writeField("use_lld", item.use_lld, .{});
    try self.writeField(
        "zig_lib_dir",
        if (item.zig_lib_dir) |f| try self.resolveLazyPath(f, SourcesForModules) else null,
        .{ .quote_str = false },
    );
    try self.writeField(
        "win32_manifest",
        if (item.win32_manifest) |f| try self.resolveLazyPath(f, SourcesForModules) else null,
        .{ .quote_str = false },
    );

    try self.writeLn("}});", .{}, .{});
    try self.writer.writeAll("\n");

    const install_exe_id = try allocFmtId(self.allocator, "install_exe", name);
    defer self.allocator.free(install_exe_id);

    const tls_install_exe_id = try allocFmtId(self.allocator, "tls_install_exe", name);
    defer self.allocator.free(tls_install_exe_id);

    const run_exe_id = try allocFmtId(self.allocator, "run_exe", name);
    defer self.allocator.free(run_exe_id);

    const tls_run_exe_id = try allocFmtId(self.allocator, "tls_run_exe", name);
    defer self.allocator.free(tls_run_exe_id);

    try self.writeLn(
        \\const {s} = b.addInstallArtifact({s}, .{{}});
        \\const {s} = b.step("build-exe:{s}", "Install the {s} executable");
        \\{s}.dependOn(&{s}.step);
        \\b.getInstallStep().dependOn(&{s}.step);
        \\
        \\const {s} = b.addRunArtifact({s});
        \\if (b.args) |args| {s}.addArgs(args);
        \\const {s} = b.step("run:{s}", "Run the {s} executable");
        \\{s}.dependOn(&{s}.step);
    ,
        .{
            install_exe_id,
            exe_id,
            tls_install_exe_id,
            name,
            name,
            tls_install_exe_id,
            install_exe_id,
            install_exe_id,
            run_exe_id,
            exe_id,
            run_exe_id,
            tls_run_exe_id,
            name,
            name,
            tls_run_exe_id,
            run_exe_id,
        },
        .{},
    );
    try self.executables.put(name, item);
}

pub fn writeLibrary(self: *ConfigBuildgen, name: []const u8, item: Config.Library) !void {
    const module_id = try self.allocModuleId(name, item.root_module);
    defer self.allocator.free(module_id);

    const lib_id = try allocFmtId(self.allocator, "lib", name);
    defer self.allocator.free(lib_id);

    try self.writeLn(
        "const {s} = b.addLibrary(.{{",
        .{lib_id},
        .{},
    );

    try self.writeField("name", name, .{});
    try self.writeField("version", try semanticVersion(item.version), .{ .quote_str = false });
    try self.writeField("root_module", module_id, .{ .quote_str = false });
    try self.writeField("linkage", item.linkage, .{});
    try self.writeField("max_rss", item.max_rss, .{});
    try self.writeField("use_llvm", item.use_llvm, .{});
    try self.writeField("use_lld", item.use_lld, .{});
    try self.writeField(
        "zig_lib_dir",
        if (item.zig_lib_dir) |f| try self.resolveLazyPath(f, SourcesForModules) else null,
        .{ .quote_str = false },
    );
    try self.writeField(
        "win32_manifest",
        if (item.win32_manifest) |f| try self.resolveLazyPath(f, SourcesForModules) else null,
        .{ .quote_str = false },
    );

    try self.writeLn("}});", .{}, .{});
    try self.writer.writeAll("\n");

    const install_lib_id = try allocFmtId(self.allocator, "install_lib", name);
    defer self.allocator.free(install_lib_id);

    const tls_install_lib_id = try allocFmtId(self.allocator, "tls_install_lib", name);
    defer self.allocator.free(tls_install_lib_id);

    try self.writeLn(
        \\const {s} = b.addInstallArtifact({s}, .{{}});
        \\const {s} = b.step("build-lib:{s}", "Install the {s} library");
        \\{s}.dependOn(&{s}.step);
        \\b.getInstallStep().dependOn(&{s}.step);
    ,
        .{
            install_lib_id,
            lib_id,
            tls_install_lib_id,
            name,
            name,
            tls_install_lib_id,
            install_lib_id,
            install_lib_id,
        },
        .{},
    );
}

pub fn writeObject(self: *ConfigBuildgen, name: []const u8, item: Config.Object) !void {
    const module_id = try self.allocModuleId(name, item.root_module);
    defer self.allocator.free(module_id);

    const obj_id = try allocFmtId(self.allocator, "obj", name);
    defer self.allocator.free(obj_id);

    try self.writeLn(
        "const {s} = b.addObject(.{{",
        .{obj_id},
        .{},
    );

    try self.writeField("name", name, .{});
    try self.writeField("root_module", module_id, .{ .quote_str = false });
    try self.writeField("max_rss", item.max_rss, .{});
    try self.writeField("use_llvm", item.use_llvm, .{});
    try self.writeField("use_lld", item.use_lld, .{});
    try self.writeField(
        "zig_lib_dir",
        if (item.zig_lib_dir) |f| try self.resolveLazyPath(f, SourcesForModules) else null,
        .{ .quote_str = false },
    );

    try self.writeLn("}});", .{}, .{});
    try self.writer.writeAll("\n");

    const install_obj_id = try allocFmtId(self.allocator, "install_obj", name);
    defer self.allocator.free(install_obj_id);

    const tls_install_obj_id = try allocFmtId(self.allocator, "tls_install_obj", name);
    defer self.allocator.free(tls_install_obj_id);

    try self.writeLn(
        \\const {s} = b.addInstallArtifact({s}, .{{}});
        \\const {s} = b.step("build-obj:{s}", "Install the {s} object");
        \\{s}.dependOn(&{s}.step);
        \\b.getInstallStep().dependOn(&{s}.step);
    ,
        .{
            install_obj_id,
            obj_id,
            tls_install_obj_id,
            name,
            name,
            tls_install_obj_id,
            install_obj_id,
            install_obj_id,
        },
        .{},
    );
}

pub fn writeTest(self: *ConfigBuildgen, name: []const u8, item: Config.Test) !void {
    const module_id = try self.allocModuleId(name, item.root_module);
    defer self.allocator.free(module_id);

    const test_id = try allocFmtId(self.allocator, "test", name);
    defer self.allocator.free(test_id);

    try self.writeLn(
        "const {s} = b.addTest(.{{",
        .{test_id},
        .{},
    );

    try self.writeField("name", name, .{});
    try self.writeField("root_module", module_id, .{ .quote_str = false });
    try self.writeField("max_rss", item.max_rss, .{});
    try self.writeField("use_llvm", item.use_llvm, .{});
    try self.writeField("use_lld", item.use_lld, .{});
    try self.writeField(
        "zig_lib_dir",
        if (item.zig_lib_dir) |f| try self.resolveLazyPath(f, SourcesForModules) else null,
        .{ .quote_str = false },
    );
    try self.writeField("filters", try strSliceLiteral(item.filters), .{ .quote_str = false });

    try self.writeLn("}});", .{}, .{});

    const install_test_id = try allocFmtId(self.allocator, "install_test", name);
    defer self.allocator.free(install_test_id);

    const tls_install_test_id = try allocFmtId(self.allocator, "tls_install_test", name);
    defer self.allocator.free(tls_install_test_id);

    const run_test_id = try allocFmtId(self.allocator, "run_test", name);
    defer self.allocator.free(run_test_id);

    const tls_run_test_id = try allocFmtId(self.allocator, "tls_run_test", name);
    defer self.allocator.free(tls_run_test_id);

    try self.writeLn(
        \\const {s} = b.addInstallArtifact({s}, .{{}});
        \\const {s} = b.step("build-test:{s}", "Install the {s} test");
        \\{s}.dependOn(&{s}.step);
        \\
        \\const {s} = b.addRunArtifact({s});
        \\const {s} = b.step("test:{s}", "Run the {s} test");
        \\{s}.dependOn(&{s}.step);
        \\tls_run_test.dependOn(&{s}.step);
    ,
        .{
            install_test_id,
            test_id,
            tls_install_test_id,
            name,
            name,
            tls_install_test_id,
            install_test_id,
            run_test_id,
            test_id,
            tls_run_test_id,
            name,
            name,
            tls_run_test_id,
            run_test_id,
            run_test_id,
        },
        .{},
    );
}

pub fn writeFmt(self: *ConfigBuildgen, name: []const u8, item: Config.Fmt) !void {
    const fmt_id = try allocFmtId(self.allocator, "fmt", name);
    defer self.allocator.free(fmt_id);

    try self.writeLn(
        \\const {s} = b.addFmt(.{{
    ,
        .{fmt_id},
        .{},
    );

    try self.writeField("paths", try strSliceLiteral(item.paths) orelse "&.{}", .{ .quote_str = false });
    try self.writeField("exclude_paths", try strSliceLiteral(item.exclude_paths) orelse "&.{}", .{ .quote_str = false });
    try self.writeField("check", item.check, .{});

    try self.writeLn("}});", .{}, .{});
    try self.writer.writeAll("\n");

    const tls_run_fmt_id = try allocFmtId(self.allocator, "tls_run_fmt", name);
    defer self.allocator.free(tls_run_fmt_id);

    try self.writeLn(
        \\const {s} = b.step("fmt:{s}", "Run the {s} fmt");
        \\{s}.dependOn(&{s}.step);
        \\tls_run_fmt.dependOn(&{s}.step);
    ,
        .{ tls_run_fmt_id, name, name, tls_run_fmt_id, fmt_id, fmt_id },
        .{},
    );
}

pub fn writeRun(self: *ConfigBuildgen, name: []const u8, item: Config.Run) !void {
    const Args = @import("Args.zig");

    const args = try Args.initFromString(self.allocator, item);
    defer args.deinit();

    const run_id = try allocFmtId(self.allocator, "run", name);
    defer self.allocator.free(run_id);

    const tls_run_id = try allocFmtId(self.allocator, "tls_run", name);
    defer self.allocator.free(tls_run_id);

    try self.writeLn(
        \\const {s} = b.addSystemCommand({s});
        \\const {s} = b.step("run:{s}", "Run the {s} run");
        \\{s}.dependOn(&{s}.step);
    ,
        .{
            run_id,
            (try strSliceLiteral(args.args.items)).?,
            tls_run_id,
            name,
            name,
            tls_run_id,
            run_id,
        },
        .{},
    );
    try self.runs.put(name, item);
}

pub fn writeDependency(self: *ConfigBuildgen, name: []const u8, item: Config.Dependency) !void {
    _ = item;
    try self.writeLn(
        \\const {s} = b.dependency("{s}", .{{}});
    ,
        .{ try fmtId("dep", name), name },
        .{},
    );
    try self.dependencies.put(name, undefined);
}

pub fn writeImport(self: *ConfigBuildgen, name: []const u8, imports: [][]const u8) !void {
    for (imports) |import| {
        const module_id = try allocFmtId(self.allocator, "module", name);
        defer self.allocator.free(module_id);

        try self.writeLn(
            \\{s}.addImport("{s}", {s});
        ,
            .{ module_id, import, try self.resolveImport(import) },
            .{},
        );
    }
}

const WriteOpts = struct {
    indent: u8 = 4,
};

fn writeLn(self: *ConfigBuildgen, comptime fmt: []const u8, args: anytype, comptime opts: WriteOpts) !void {
    // first format the string
    const str = try std.fmt.allocPrint(self.allocator, fmt, args);
    defer self.allocator.free(str);

    // then add indentation + newlines
    var it = std.mem.splitScalar(u8, str, '\n');
    while (it.next()) |line| {
        if (line.len == 0) {
            try self.writer.writeAll("\n");
        } else {
            try self.writer.print("{s}{s}\n", .{ [_]u8{' '} ** opts.indent, line });
        }
    }
}

const WriteFieldOpts = struct {
    indent: u8 = 8,
    quote_str: bool = true,
};

fn writeFields(self: *ConfigBuildgen, kvs: anytype, comptime opts: WriteFieldOpts) !void {
    for (kvs) |kv| {
        self.writeField(kv[0], kv[1], opts);
    }
}

fn writeField(self: *ConfigBuildgen, key: []const u8, value: anytype, comptime opts: WriteFieldOpts) !void {
    const value_typ1 = @typeInfo(@TypeOf(value));
    const value_typ, const value_ = if (value_typ1 == .optional) blk: {
        if (value == null) {
            return;
        }
        break :blk .{ @typeInfo(value_typ1.optional.child), value.? };
    } else .{ value_typ1, value };

    const value_str = switch (value_typ) {
        .@"enum" => try std.fmt.allocPrint(self.allocator, ".{}", .{std.zig.fmtId(@tagName(value_))}),
        .bool => if (value_) "true" else "false",
        .int => try std.fmt.allocPrint(self.allocator, "{d}", .{value_}),
        // string
        .pointer => |p| blk: {
            if (p.size == .slice) {
                const childInfo = @typeInfo(p.child);
                if (childInfo == .int and childInfo.int.bits == 8) {
                    if (opts.quote_str) {
                        break :blk try std.fmt.allocPrint(self.allocator, "\"{s}\"", .{value_});
                    } else {
                        break :blk value_;
                    }
                }
            }
            return error.InvalidType;
        },
        else => return error.InvalidType,
    };

    try self.writeLn(
        ".{s} = {s},",
        .{
            key,
            value_str,
        },
        .{ .indent = opts.indent },
    );
}

/// return the module name, writing the module definition first if necessary
fn allocModuleId(self: *ConfigBuildgen, name: []const u8, item: Config.ModuleLink) ![]const u8 {
    return try allocFmtId(
        self.allocator,
        "module",
        switch (item) {
            .name => |n| n,
            .module => |m| blk: {
                const n = m.name orelse name;
                try self.writeModule(n, m);
                try self.writer.writeAll("\n");
                break :blk n;
            },
        },
    );
}

/// used for temp strings
/// This is safe because only a single consumer of scratch exists at a time
threadlocal var scratch: [4096]u8 = undefined;

fn lazyPathSlice(paths_maybe: ?[][]const u8) !?[]u8 {
    if (paths_maybe) |paths| {
        var w = std.io.fixedBufferStream(&scratch);
        const writer = w.writer();

        try writer.writeAll("&[_]std.Build.LazyPath{ ");

        for (paths, 0..) |path, i| {
            try writer.print("b.path(\"{s}\")", .{path});
            if (i != paths.len - 1) {
                try writer.writeAll(", ");
            }
        }

        try writer.writeAll(" }");
        return w.getWritten();
    } else {
        return null;
    }
}
fn buildId(build_id: ?[]const u8) !?[]const u8 {
    if (build_id) |b| {
        return try std.fmt.bufPrint(
            &scratch,
            \\std.zig.BuildId.parse("{s}") catch @panic("invalid build id")
        ,
            .{b},
        );
    } else {
        return null;
    }
}

fn resolvedTarget(target: ?[]const u8) ![]const u8 {
    if (target) |t| {
        return try std.fmt.bufPrint(
            &scratch,
            \\b.resolveTargetQuery(std.Target.Query.parse(.{{.arch_os_abi = "{s}"}}) catch @panic("invalid target"))
        ,
            .{t},
        );
    } else {
        return @constCast("target");
    }
}

fn optimize(opt: ?std.builtin.OptimizeMode) ![]const u8 {
    if (opt) |o| {
        return try std.fmt.bufPrint(
            &scratch,
            \\.{s}
        ,
            .{@tagName(o)},
        );
    } else {
        return @constCast("optimize");
    }
}

fn semanticVersion(version: ?[]const u8) !?[]u8 {
    if (version) |v| {
        return try std.fmt.bufPrint(
            &scratch,
            "std.SemanticVersion.parse(\"{s}\") catch @panic(\"invalid version\")",
            .{v},
        );
    } else {
        return null;
    }
}

pub fn strSliceLiteral(str_slice_maybe: ?[]const []const u8) !?[]u8 {
    if (str_slice_maybe) |str_slice| {
        var w = std.io.fixedBufferStream(&scratch);
        const writer = w.writer();

        try writer.writeAll("&[_][]const u8{ ");

        for (str_slice, 0..) |str, i| {
            try writer.print("\"{s}\"", .{str});
            if (i != str_slice.len - 1) {
                try writer.writeAll(", ");
            }
        }

        try writer.writeAll(" }");
        return w.getWritten();
    } else {
        return null;
    }
}

pub fn strTupleLiteral(str_slice_maybe: ?[]const []const u8) !?[]u8 {
    if (str_slice_maybe) |str_slice| {
        var w = std.io.fixedBufferStream(&scratch);
        const writer = w.writer();

        try writer.writeAll(".{ ");

        for (str_slice, 0..) |str, i| {
            try writer.print("\"{s}\"", .{str});
            if (i != str_slice.len - 1) {
                try writer.writeAll(", ");
            }
        }

        try writer.writeAll(" }");
        return w.getWritten();
    } else {
        return null;
    }
}

fn enumSliceLiteral(enum_name: []const u8, enum_slice: []const []const u8) ![]u8 {
    var w = std.io.fixedBufferStream(&scratch);
    const writer = w.writer();

    try writer.print("&[_]{s}{{ ", .{enum_name});

    for (enum_slice, 0..) |enum_value, i| {
        try writer.print(".{s}", .{enum_value});
        if (i != enum_slice.len - 1) {
            try writer.writeAll(", ");
        }
    }

    try writer.writeAll(" }");
    return w.getWritten();
}

fn resolveImport(self: *ConfigBuildgen, import: []const u8) ![]const u8 {
    if (self.modules.contains(import)) {
        return try fmtId("module", import);
    } else if (self.options_modules.contains(import)) {
        return try fmtId("options_module", import);
    } else if (self.dependencies.contains(import)) {
        const dep_id = try allocFmtId(self.allocator, "dep", import);
        defer self.allocator.free(dep_id);

        return try std.fmt.bufPrint(&scratch, "{s}.module(\"{s}\")", .{ dep_id, import });
    } else {
        // one last try, maybe it's a dependency with a custom module, eg "dep:module_a"
        var parts = std.mem.splitScalar(u8, import, ':');
        const first = parts.first();
        if (self.dependencies.contains(first)) {
            const dep_id = try allocFmtId(self.allocator, "dep", import);
            defer self.allocator.free(dep_id);
            return try std.fmt.bufPrint(&scratch, "{s}.module(\"{s}\")", .{ dep_id, parts.rest() });
        }

        return try std.fmt.bufPrint(&scratch, "@panic(\"missing import {s}\")", .{import});
    }
}

const SourcesForWriteFiles = .{ .write_files, .dependencies, .options };
const SourcesForOptions = .{ .write_files, .dependencies };
const SourcesForModules = .{ .write_files, .dependencies, .options };

/// Use colon delimiters to differentiate between
/// - simple paths, eg "src/main.zig"
/// - writefiles paths, eg "writefiles:src/main.zig"
/// - TODO options paths, eg "options:foo"
/// - dependency paths, both
///   - named writefiles paths, eg "dep:writefiles:src/main.zig"
///   - named lazypath paths, eg "dep:src/main.zig"
/// Use sources to limit and order which sources to try
/// - write_files, options, dependencies, runs_output
fn resolveLazyPath(self: *ConfigBuildgen, path: []const u8, comptime sources: anytype) ![]const u8 {
    comptime {
        for (sources) |source| {
            switch (source) {
                .write_files, .options, .dependencies, .runs_output => {},
                else => @compileError("Invalid source"),
            }
        }
    }
    var parts = std.mem.splitScalar(u8, path, ':');
    const first = parts.first();
    inline for (sources) |source| {
        switch (source) {
            .write_files => if (self.write_files.contains(first)) {
                const write_files_id = try allocFmtId(self.allocator, "write_files", first);
                defer self.allocator.free(write_files_id);

                return try std.fmt.bufPrint(
                    &scratch,
                    "{s}.getDirectory().path(b, \"{s}\")",
                    .{ write_files_id, parts.rest() },
                );
            },
            .options => if (self.options.get(first)) |option| blk: {
                if (!std.mem.eql(u8, option.type_name, "std.Build.LazyPath")) {
                    break :blk;
                }

                const option_id = try allocFmtId(self.allocator, "option", first);
                defer self.allocator.free(option_id);

                if (option.optional) {
                    return try std.fmt.bufPrint(
                        &scratch,
                        "{s} orelse @panic(\"missing option {s}\")",
                        .{ option_id, first },
                    );
                } else {
                    return try std.fmt.bufPrint(
                        &scratch,
                        "{s}",
                        .{option_id},
                    );
                }
            },
            .dependencies => if (self.dependencies.contains(first)) blk: {
                const dep_id = try allocFmtId(self.allocator, "dep", first);
                defer self.allocator.free(dep_id);

                const next = parts.next() orelse break :blk;
                const last = parts.next();
                // TODO there should be an error if there's even more data after?, eg dep:writefiles:src/main.zig:wtf_is_this

                if (last) |l| {
                    return try std.fmt.bufPrint(
                        &scratch,
                        "{s}.namedWriteFiles(\"{s}\").getDirectory().path(b, \"{s}\")",
                        .{ dep_id, next, l },
                    );
                } else {
                    return try std.fmt.bufPrint(
                        &scratch,
                        "{s}.namedLazyPath(\"{s}\")",
                        .{ dep_id, next },
                    );
                }
            },
            else => unreachable,
        }
    }
    return try std.fmt.bufPrint(
        &scratch,
        "b.path(\"{s}\")",
        .{path},
    );
}

/// wrapper around std.zig.fmtId that includes a prefix string
fn fmtId(prefix: []const u8, name: []const u8) ![]const u8 {
    var fmt_scratch: [4096]u8 = undefined;
    return try std.fmt.bufPrint(&scratch, "{}", .{std.zig.fmtId(try std.fmt.bufPrint(&fmt_scratch, "{s}_{s}", .{ prefix, name }))});
}

/// wrapper around std.zig.fmtId that includes a prefix string, consumer is responsible for freeing
fn allocFmtId(allocator: std.mem.Allocator, prefix: []const u8, name: []const u8) ![]const u8 {
    return try allocator.dupe(u8, try fmtId(prefix, name));
}
