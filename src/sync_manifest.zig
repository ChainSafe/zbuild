const std = @import("std");
const fatal = std.process.fatal;
const builtin = @import("builtin");
const Manifest = @import("Manifest.zig");
const GlobalOptions = @import("GlobalOptions.zig");
const strTupleLiteral = @import("ConfigBuildgen.zig").strTupleLiteral;
const runZigFetch = @import("run_zig.zig").runZigFetch;

const mem = std.mem;
const Allocator = mem.Allocator;
const Ast = std.zig.Ast;
const Color = std.zig.Color;

pub const SyncManifestOpts = struct {
    out_dir: ?[]const u8 = null,
};

pub fn syncManifest(gpa: Allocator, arena: Allocator, global_opts: GlobalOptions, config: Config, opts: SyncManifestOpts) !void {
    // naive strategy for now
    // fetch existing manifest (if any)
    // write new manifest based on config (except for dependencies, which get copied over from existing manifest)
    // if any dependencies are different or added, call zig fetch on them

    const build_root_directory = if (opts.out_dir) |manifest_dir|
        try std.fs.cwd().openDir(manifest_dir, .{})
    else
        std.fs.cwd();
    var manifest = try Manifest.load(gpa, arena, .{
        .dir = build_root_directory,
        .basename = "build.zig.zon",
        .color = .auto,
    });
    defer {
        if (manifest) |*m| {
            m.ast.deinit(gpa);
            m.deinit(gpa);
        }
    }

    const new_manifest_bytes = try allocPrintManifest(gpa, config, manifest);
    defer gpa.free(new_manifest_bytes);
    try build_root_directory.writeFile(.{
        .sub_path = "build.zig.zon",
        .data = new_manifest_bytes,
    });
    if (config.dependencies) |dependencies| {
        for (dependencies.keys(), dependencies.values()) |name, config_dep| {
            const path_or_url = switch (config_dep) {
                .path => |p| p.path,
                .url => |u| u.url,
            };

            if (manifest) |m| {
                if (m.dependencies.get(name)) |manifest_dep| {
                    if (depEql(manifest_dep, config_dep)) {
                        continue;
                    }
                }
            }
            try runZigFetch(
                gpa,
                arena,
                .{ .cwd = global_opts.project_dir },
                global_opts.getZigEnv(),
                path_or_url,
                .{ .exact = name },
            );
        }
    }
}

pub const LoadManifestOptions = struct {
    dir: std.fs.Dir,
    basename: []const u8,
    color: Color,
};

const Config = @import("Config.zig");

const manifest_template =
    \\// This file is generated by zbuild. Do not edit manually.
    \\
    \\.{{
    \\    .name = .{s},
    \\    .version = "{s}",
    \\    .fingerprint = {s},
    \\    .minimum_zig_version = "{s}",
    \\    .dependencies = {s},
    \\    .paths = {s},
    \\}}
    \\
;

fn allocPrintManifest(allocator: Allocator, config: Config, manifest: ?Manifest) ![]const u8 {
    // TODO fix this
    const paths: ?[][]const u8 = config.paths;
    return try std.fmt.allocPrint(allocator, manifest_template, .{
        config.name,
        config.version,
        config.fingerprint,
        config.minimum_zig_version,
        if (manifest) |m|
            m.ast.getNodeSource(m.dependencies_node)
        else
            ".{}",
        try strTupleLiteral(paths) orelse
            \\.{ "build.zig", "build.zig.zon", "src" }
        ,
    });
}

fn depEql(manifest_dep: Manifest.Dependency, config_dep: Config.Dependency) bool {
    if (config_dep == .path and manifest_dep.location != .path) {
        return false;
    }
    if (config_dep == .url and manifest_dep.location != .url) {
        return false;
    }
    const manifest_path_or_url, const manifest_hash, const config_path_or_url, const config_hash = switch (config_dep) {
        .path => .{ manifest_dep.location.path, manifest_dep.hash, config_dep.path.path, config_dep.path.hash },
        .url => .{ manifest_dep.location.url, manifest_dep.hash, config_dep.url.url, config_dep.url.hash },
    };
    if (!std.mem.eql(u8, manifest_path_or_url, config_path_or_url)) {
        return false;
    }
    if (config_hash == null) {
        return true;
    }
    if (manifest_hash == null) {
        return false;
    }
    return std.mem.eql(u8, manifest_hash.?, config_hash.?);
}
